// Simplified culori-compatible library for ColorDesigner
// Only includes essential functions for color conversion

(function(global) {
    'use strict';
    
    // Helper functions
    function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
    }
    
    function round(n, decimals = 2) {
        const factor = Math.pow(10, decimals);
        return Math.round(n * factor) / factor;
    }
    
    // Parse HEX color
    function parseHex(hex) {
        if (typeof hex !== 'string') return null;
        hex = hex.trim();
        if (!hex.startsWith('#')) hex = '#' + hex;
        
        const match = hex.match(/^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/);
        if (!match) return null;
        
        let r, g, b;
        if (match[1].length === 3) {
            r = parseInt(match[1][0] + match[1][0], 16) / 255;
            g = parseInt(match[1][1] + match[1][1], 16) / 255;
            b = parseInt(match[1][2] + match[1][2], 16) / 255;
        } else {
            r = parseInt(match[1].substr(0, 2), 16) / 255;
            g = parseInt(match[1].substr(2, 2), 16) / 255;
            b = parseInt(match[1].substr(4, 2), 16) / 255;
        }
        
        return { mode: 'rgb', r, g, b };
    }
    
    // RGB to HSL conversion
    function rgbToHsl(color) {
        const r = color.r, g = color.g, b = color.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
            }
        }
        
        return { mode: 'hsl', h: h * 360, s: s * 100, l: l * 100 };
    }
    
    // HSL to RGB conversion
    function hslToRgb(hsl) {
        let h = hsl.h / 360;
        let s = hsl.s / 100;
        let l = hsl.l / 100;
        let r, g, b;
        
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        
        return { mode: 'rgb', r, g, b };
    }
    
    // RGB to OKLab conversion (simplified)
    function rgbToOklab(color) {
        // Simplified conversion
        const r = color.r, g = color.g, b = color.b;
        
        // Convert to linear RGB
        const lr = r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        const lg = g <= 0.04045 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
        const lb = b <= 0.04045 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
        
        // Convert to XYZ (simplified)
        const x = 0.8189330101 * lr + 0.3618667424 * lg - 0.1288597137 * lb;
        const y = 0.0329845436 * lr + 0.9293118715 * lg + 0.0361456387 * lb;
        const z = 0.0482003018 * lr + 0.2643662691 * lg + 0.633851707 * lb;
        
        // Convert to OKLab (simplified approximation)
        const l = 0.5 * x + 0.5 * y;
        const a = 1.5 * (x - y);
        const b_ = 0.5 * (y - z);
        
        return { mode: 'oklab', l: clamp(l, 0, 1), a: clamp(a, -0.4, 0.4), b: clamp(b_, -0.4, 0.4) };
    }
    
    // OKLab to OKLCH
    function oklabToOklch(color) {
        const c = Math.sqrt(color.a * color.a + color.b * color.b);
        let h = Math.atan2(color.b, color.a) * 180 / Math.PI;
        if (h < 0) h += 360;
        return { mode: 'oklch', l: color.l, c: c, h: h };
    }
    
    // RGB to LCH conversion (via Lab)
    function rgbToLch(color) {
        // Simplified Lab conversion
        const r = color.r, g = color.g, b = color.b;
        
        // Convert to linear
        const lr = r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        const lg = g <= 0.04045 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
        const lb = b <= 0.04045 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
        
        // XYZ conversion
        const x = 0.4124564 * lr + 0.3575761 * lg + 0.1804375 * lb;
        const y = 0.2126729 * lr + 0.7151522 * lg + 0.072175 * lb;
        const z = 0.0193339 * lr + 0.119192 * lg + 0.9503041 * lb;
        
        // Lab conversion (simplified)
        const l = 116 * Math.cbrt(y) - 16;
        const a = 500 * (Math.cbrt(x) - Math.cbrt(y));
        const b_ = 200 * (Math.cbrt(y) - Math.cbrt(z));
        
        // LCH conversion
        const c = Math.sqrt(a * a + b_ * b_);
        let h = Math.atan2(b_, a) * 180 / Math.PI;
        if (h < 0) h += 360;
        
        return { mode: 'lch', l: l, c: c, h: h };
    }
    
    // Format functions
    function formatHex(color) {
        const toHex = (c) => {
            const hex = Math.round(clamp(c, 0, 1) * 255).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        return '#' + toHex(color.r) + toHex(color.g) + toHex(color.b);
    }
    
    function formatRgb(color) {
        const r = Math.round(clamp(color.r, 0, 1) * 255);
        const g = Math.round(clamp(color.g, 0, 1) * 255);
        const b = Math.round(clamp(color.b, 0, 1) * 255);
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    function formatHsl(color) {
        const hsl = rgbToHsl(color);
        return `hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`;
    }
    
    function formatOklch(color) {
        const oklab = rgbToOklab(color);
        const oklch = oklabToOklch(oklab);
        return `oklch(${round(oklch.l, 3)} ${round(oklch.c, 3)} ${round(oklch.h, 1)})`;
    }
    
    function formatLch(color) {
        const lch = rgbToLch(color);
        return `lch(${Math.round(lch.l)}% ${Math.round(lch.c)} ${Math.round(lch.h)})`;
    }
    
    // Main culori object
    const culori = {
        parse: function(color) {
            return parseHex(color);
        },
        
        formatHex: function(color) {
            if (color.mode === 'rgb') return formatHex(color);
            return formatHex(hslToRgb(color));
        },
        
        formatRgb: function(color) {
            if (color.mode === 'rgb') return formatRgb(color);
            return formatRgb(hslToRgb(color));
        },
        
        formatHsl: function(color) {
            if (color.mode === 'hsl') return formatHsl(color);
            if (color.mode === 'rgb') return formatHsl(color);
            return formatHsl(rgbToHsl(hslToRgb(color)));
        },
        
        oklch: function(color) {
            if (color.mode === 'rgb') return oklabToOklch(rgbToOklab(color));
            return oklabToOklch(rgbToOklab(hslToRgb(color)));
        },
        
        lch: function(color) {
            if (color.mode === 'rgb') return rgbToLch(color);
            return rgbToLch(hslToRgb(color));
        },
        
        formatCss: function(color) {
            if (color.mode === 'oklch') {
                return `oklch(${round(color.l, 3)} ${round(color.c, 3)} ${round(color.h, 1)})`;
            }
            if (color.mode === 'lch') {
                return `lch(${Math.round(color.l)}% ${Math.round(color.c)} ${Math.round(color.h)})`;
            }
            return formatHex(color);
        },
        
        interpolate: function(colors, factor) {
            // Simple linear interpolation between two colors
            if (colors.length !== 2) return colors[0];
            let c1 = colors[0];
            let c2 = colors[1];
            
            // Normalize both colors to RGB objects
            if (typeof c1 === 'string') {
                c1 = parseHex(c1);
            }
            if (typeof c2 === 'string') {
                c2 = parseHex(c2);
            }
            
            // Validate parsed colors
            if (!c1 || !c2) {
                return { mode: 'rgb', r: 0.5, g: 0.5, b: 0.5 };
            }
            
            // Ensure both have RGB values
            const r1 = c1.r !== undefined ? c1.r : 0.5;
            const g1 = c1.g !== undefined ? c1.g : 0.5;
            const b1 = c1.b !== undefined ? c1.b : 0.5;
            const r2 = c2.r !== undefined ? c2.r : 0.5;
            const g2 = c2.g !== undefined ? c2.g : 0.5;
            const b2 = c2.b !== undefined ? c2.b : 0.5;
            
            return {
                mode: 'rgb',
                r: r1 + (r2 - r1) * factor,
                g: g1 + (g2 - g1) * factor,
                b: b1 + (b2 - b1) * factor
            };
        }
    };
    
    // Expose to global scope
    global.culori = culori;
    
})(window);